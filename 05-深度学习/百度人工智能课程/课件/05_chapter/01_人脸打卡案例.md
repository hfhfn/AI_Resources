# 5.1 人脸打卡案例

## 5.1.1 案例架构介绍

这个案例实现在校学员自动人脸打卡系统，功能上分两部分，首先需要学员登记个人信息和人脸照片，第二部分为自动人脸识别。技术上利用传智Python学科之前学习的前端网页制作，后端服务器实现，包括数据库操作，结合百度人工智能提供的人脸识别实现一个简单的人脸打卡系统，学员可以通过这个系统实现信息登记和自动人脸识别，显示学员的的登记信息。系统的架构如下：

![案例架构](images/01_案例架构.png)

Web前端提供了学员注册的管理功能和人脸实时打卡的界面展示功能。App服务器处理前端的信息注册和打卡请求。App服务器调用数据库来保存学员的信息。百度人工智能提供人脸照片的存储和搜索功能。

## 5.1.2 Web 前端

Web前端提供功能入口，包括信息管理和打卡两部分。信息管理部分，只提供了注册一个功能，实际的产品当然还必须包括查询，删除等基本功能。第二个功能就是打卡。

### 5.1.2.1前端入口

![web入口](images/02_web入口.png)

代码：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>首页</title>
    <link rel="stylesheet" type="text/css" href="../static/css/main.css">
</head>
<body>

<div class="sys_title"></div>

<div class="video_bg">
    <video id="video" autoplay="autoplay" class="video_show"></video>
</div>

<div class="btns_con">
    <a href="register" class="fl">注 册</a>
    <a href="clockin" class="fr">打 卡</a>
</div>

<script type="text/javascript">
    var video = document.getElementById("video");
    var errocb = function (code) {
        alert(code);
    };
    if (navigator.getUserMedia) { // 标准的API
        navigator.getUserMedia({"video": true}, function (stream) {
            video.src = window.webkitURL.createObjectURL(stream);//stream;
            video.play();
        }, errocb);
    } else if (navigator.webkitGetUserMedia) { // WebKit 核心的API

        console.log(navigator.webkitGetUserMedia);
        navigator.webkitGetUserMedia({"video": true}, function (stream) {
            video.src = window.webkitURL.createObjectURL(stream);
            video.play();
        }, errocb);
    }
</script>

</body>
</html>
```



在注册页面可以进行拍照和填写登记信息：

![注册](images\03_注册.png)

注册页面代码：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>注册</title>
    <link rel="stylesheet" type="text/css" href="../static/css/main.css">
</head>

<body>
<div class="sys_title"></div>
<div class="video_bg">
    <video id="video" width="550" height="420" autoplay="autoplay" class="video_show"></video>
    <img id="picture" style="width:550px;height:420px;display:none;margin-top:10px" class="video_show">
    
    <button id="tkpicture" onclick="takePicture(this)" class="tkpicture">拍照</button>
    <button id="retkpicture" style="display: none;" onclick="reTackPicture()" class="tkpicture">重拍</button>

</div>
<canvas id="mycanvas" width="550" height="420" style="display:none;"></canvas>


<form method="post" class="reg_form">
    <div style="color: red;margin-bottom:5px;">{{ msg }}</div>
    <div class="form_group">
        <label>姓名：</label><input type="text" name="stu_name" class="input_txt">
    </div>
    <div class="form_group">
        <label class="ml10">班级：</label><input type="text" name="stu_class" class="input_txt">
    </div>
    <div class="form_group">
        <label>学号：</label><input type="text" name="stu_num"  class="input_txt">
    </div>
    <div class="form_group">
    <label class="ml10">性别：</label><input type="radio" name="gender" value="MAN">男 <input type="radio" name="gender" value="WOMAN">女
    </div>
    <input id="img_data" name="img_data" type="hidden">   
    <input type="submit" value="提交注册" class="btn_sub">
</form>


<script type="text/javascript">
    var video = document.getElementById("video");
    var canv = document.getElementById('mycanvas');
    var context = canv.getContext("2d");
    var errocb = function (code) {
        alert(code);
    };
    if (navigator.getUserMedia) { // 标准的API
        navigator.getUserMedia({"video": true}, function (stream) {
            video.src = window.webkitURL.createObjectURL(stream);//stream;
            video.play();
        }, errocb);
    } else if (navigator.webkitGetUserMedia) { // WebKit 核心的API

        console.log(navigator.webkitGetUserMedia);
        navigator.webkitGetUserMedia({"video": true}, function (stream) {
            video.src = window.webkitURL.createObjectURL(stream);
            video.play();
        }, errocb);
    }

    function takePicture(obj) {
        event.preventDefault()
        var width = 550;
        var height = 410;
        context.drawImage(video, 0, 0, parseInt(width), parseInt(height));
        var canvasEl = document.getElementById("mycanvas")
        var imgData = canvasEl.toDataURL("image/png");
        console.log(imgData)
        var imgEl = document.getElementById("picture")
        imgEl.setAttribute('src', imgData)
        obj.style.display = 'none';

        document.getElementById('video').style.display = 'none';
        document.getElementById('picture').style.display = 'block';
        document.getElementById('retkpicture').style.display = 'block';
        document.getElementById('img_data').value= imgData
    }

    function reTackPicture() {
        event.preventDefault()
        document.getElementById('video').style.display = 'block';
        document.getElementById('picture').style.display = 'none';
        document.getElementById('tkpicture').style.display = 'block';
        document.getElementById('retkpicture').style.display = 'none';
    }

</script>

</body>
</html>
```



打卡页面自动对摄像头前的人脸进行识别，如果成功识别到人脸就显示相关信息。

![打卡](images/04_打卡.png)

Web端负责获取照片，输入学员信息和展示识别结:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <script src="../static/js/jquery-1.12.4.min.js"></script>
    <title>打卡界面</title>
    <link rel="stylesheet" type="text/css" href="../static/css/main.css">
</head>
<body>
<div class="sys_title"></div>


<div class="video_bg">
    <video id="video" autoplay="autoplay" class="video_show"></video>
</div>

<div id="show_result" class="show_result">
    <div></div>
    <div></div>
    <div></div>
    <div></div>
    <div></div>
</div>

<canvas id="canvas" width="640", height="480", hidden></canvas>

<script type="text/javascript">
    var video = document.getElementById("video");
    var context = canvas.getContext("2d");
    var errocb = function (code) {
        alert(code);
    };
    if (navigator.getUserMedia) { // 标准的API
        navigator.getUserMedia({"video": true}, function (stream) {
            video.src = window.webkitURL.createObjectURL(stream);//stream;
            video.play();
        }, errocb);
    } else if (navigator.webkitGetUserMedia) { // WebKit 核心的API
        console.log(navigator.webkitGetUserMedia);
        navigator.webkitGetUserMedia({"video": true}, function (stream) {
            video.src = window.webkitURL.createObjectURL(stream);
            video.play();
        }, errocb);
    }

    function takePicture() {
        var width = parseInt(video.videoWidth)
        var height = parseInt(video.videoHeight)
        context.drawImage(video, 0, 0, parseInt(width), parseInt(height));
        var canvasEl = document.getElementById("canvas")
        var imgData = canvasEl.toDataURL("image/png");

        $.ajax({
            url: "/clockin",
            type: "post",
            contentType: "application/json",
            data: JSON.stringify({"img_data": imgData}),
            success: function (resp) {
                console.log(resp)
                var content = ""
                console.log(resp.errno)
                if (resp.errno == 0) {
                    // 识别成功
                    content += "识别成功：" + JSON.stringify(resp.dict)
                } else {
                    // 识别失败
                    content += "识别失败：" + resp.errmsg + "；错误码：" + resp.errno
                }

                var $div = $("#show_result")
                // 发起请求
                $div.append('<div>'+content+'</div>')
                // 滚动到最底部
                $div.scrollTop($div[0].scrollHeight)
            }
        })
    }

    setInterval(function () {
        takePicture()
    }, 1000)
</script>

</body>
</html>
```



## 5.1.3 App服务器

App服务器负责处理前端界面发送过来的请求。包括学员信息管理部分和打卡。学员的信息除了照片都存放在MySQL数据库中，照片存放在百度人脸库中。

### 5.1.3.1 MySQL数据库结构

MySQL的安装和配置不在本课程内介绍。首先在MySQL中创建数据库为"school"。

```python
mysql> CREATE DATABASE school;
```

在App服务器代码中定义名为students的表格。Flash代码的表格类定义为：

```python
class Student(db.Model):
    """
    定义数据库表格 结构类
    """
    __tablename__ = "students"
    # 标号
    id = db.Column(db.Integer, primary_key=True)
    # 学生姓名
    st_name = db.Column(db.String(128), nullable=False)
    # 学生班级
    st_class = db.Column(db.String(128), nullable=False)
    # 学生学号
    st_num = db.Column(db.String(128), unique=True, nullable=False)
    # 性别
    st_gender = db.Column(db.Enum("MAN","WOMAN"), default="MAN")

    def to_dict(self):
        return {
            "name": self.st_name,
            "class": self.st_class,
            "num": self.st_num,
            "gender": "男" if self.gender == "MAN" else "女"
        }
```

函数to_dict是为了方便把表格中查询的信息转化为字典数据。

### 5.1.3.2 服务器的注册函数

接受两种方式访问，一种是“GET"，一种是”POST"。'GET'方式把注册页面返回给客户端。‘POST’方式表示客户端提交了用户信息和照片。

步骤：

1. 处理‘POST’请求时，首先获取用户名，班级，学号和性别信息。
2. 构建一个Student类的对象，调用SQLAlchemy函数，写入数据库。
3. 获取人脸照片，调用自定义的BaiduFace类的add_user方法添加到百度人脸库中。

```python
@app.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'GET':
        # 渲染注册模板
        return render_template('register.html')

    # POST 请求, 获取提交上来的参数
    st_name = request.form.get('stu_name')
    st_class = request.form.get('stu_class')
    st_num = request.form.get('stu_num')
    st_gender = request.form.get('gender')
    # print(st_name, st_class, st_num, st_gender)

    if all([st_name, st_class, st_num, st_gender]) == False:
        return render_template('register.html', msg='信息不全,请重新填写')

    # 初始化模板类,写入数据库
    student = Student()
    student.st_name = st_name
    student.st_class = st_class
    student.st_num = st_num
    student.st_gender = st_gender

    try:
        db.session.add(student)
        db.session.commit()
    except Exception as e:
        print('添加到数据库失败 {}'.format(e))
        return render_template('register.html', msg='信息不对, 请重新填写')

    # 获取图片内容
    img_data = request.form.get('img_data')

    # 上传百度, 用学生的学号作为唯一标识
    result = bf.add_user(img_data.split(',')[1], '1', st_num)

    if result != 0:
        # 需要把对应的信息从数据库中删除, 避免下次添加出错
        db.session.delete(student)

        return render_template('register.html', msg='图片不符合要求, 请重新拍照')

    # 成功添加后 重新定向到主页
    return redirect(url_for('index'))
```



### 5.1.3.3 服务器的打卡函数 

打开函数读取前端上传的照片，调用自定义类BaiduFace的搜索函数search_user进行人脸搜索，返回学生标记。根据学号在数据库中查询学员的具体信息，返回到前端。

步骤：

1. 读取前端上传的照片；
2. 调用BaiduFace类的search_user函数搜索人脸库，如果有匹配，返回学员的学号；
3. 根据返回的学号，从数据库中查询学员信息；
4. 返回学员信息给前端页面。

```python
@app.route('/clockin', methods=['GET', 'POST'])
def clockin():
    if request.method == 'GET':
        # 渲染打卡界面
        return render_template('clockin.html')

    # POST
    # 获取图片内容
    img_data = request.json.get('img_data')
	
    # 在百度人脸库中查询人脸
    result = bf.search_user(img_data.split(',')[1], '1')

    if result['error'] == 0:
        # 识别成功， 获取学号， 查询数据库获得更多学生信息
        student = Student.query.filter(Student.st_num == result['st_num']).first()
        if student:
            return jsonify(errno=0, errmsg='识别成功', dict=student.to_dict())
        else:
            return jsonify(errno=-1, errmsg='未能识别该学生')

    return jsonify(errno=result['error'], errmsg=result['error_msg'])
```


## 5.1.4 人脸库的管理

### 5.1.4.1 介绍 

人脸打卡系统需要涉及到人脸库的管理，人脸照片的登记和搜索。百度人工智能平台提供人脸库管理相关接口，要完成1：N或者M：N识别，首先需要构建一个人脸库，用于存放所有人脸特征，相关接口如下：

- **人脸注册**：向人脸库中添加人脸
- **人脸更新**：更新人脸库中指定用户下的人脸信息
- **人脸删除**：删除指定用户的某张人脸
- **用户信息查询**：查询人脸库中某个用户的详细信息
- **获取用户人脸列表**：获取某个用户组中的全部人脸列表
- **获取用户列表**：查询指定用户组中的用户列表
- **复制用户**：将指定用户复制到另外的人脸组
- **删除用户**：删除指定用户
- **创建用户组**：创建一个新的用户组
- **删除用户组**：删除指定用户组
- **组列表查询**：查询人脸库中用户组的列表

**人脸库结构**

人脸库、用户组、用户、用户下的人脸**层级关系**如下所示：

```
|- 人脸库(appid)
   |- 用户组一（group_id）
      |- 用户01（uid）
         |- 人脸（faceid）
      |- 用户02（uid）
         |- 人脸（faceid）
         |- 人脸（faceid）
         ....
       ....
   |- 用户组二（group_id）
   |- 用户组三（group_id）
   ....
```

**关于人脸库的设置限制**

- 每个开发者账号可以创建100个appid；
- **每个appid对应一个人脸库，且不同appid之间，人脸库互不相通**；
- 每个人脸库下，可以创建多个用户组，用户组（group）数量**没有限制**；
- 每个用户组（group）下，可添加**无限**个user_id，**无限**张人脸（注：为了保证查询速度，单个group中的人脸容量上限建议为**80万**）；
- 每个用户（user_id）所能注册的最大人脸数量**没有限制**；

> 提醒：每个人脸库对应一个appid，一定确保不要轻易删除后台应用列表中的appid，删除后则此人脸库将失效，无法进行任何查找！

**质量判断**

为了保证识别效果，请控制注册人脸的质量，在调用人脸注册接口时使用质量控制和活体控制参数保证图片的质量以及注册进入人脸库的人脸是活体：

### 5.1.4.2 照片质量检查
* 获取人脸照片，调用百度人工智能的人脸检测API AipFace.detect()检查照片的质量，调用时 face_field参数中请求quality。基于返回结果判断是否适合后续业务.

  * option['face_field] = 'quality'

  下表为一般的标准


| 指标       | 字段与解释                                                   | 推荐数值界限                                                 |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 遮挡范围   | **occlusion**，取值范围[0~1]，0为无遮挡，1是完全遮挡 含有多个具体子字段，表示脸部多个部位 通常用作判断头发、墨镜、口罩等遮挡 | left_eye : 0.6, #左眼被遮挡的阈值 right_eye : 0.6, #右眼被遮挡的阈值 nose : 0.7, #鼻子被遮挡的阈值 mouth : 0.7, #嘴巴被遮挡的阈值 left_cheek : 0.8, #左脸颊被遮挡的阈值 right_cheek : 0.8, #右脸颊被遮挡的阈值 chin_contour : 0.6, #下巴被遮挡阈值 |
| 模糊度范围 | **blur**，取值范围[0~1]，0是最清晰，1是最模糊                | 小于0.7                                                      |
| 光照范围   | **illumination**，取值范围[0~255] 脸部光照的灰度值，0表示光照不好 以及对应客户端SDK中，YUV的Y分量 | 大于40                                                       |
| 姿态角度   | **Pitch**：三维旋转之俯仰角度[-90(上), 90(下)] **Roll**：平面内旋转角[-180(逆时针), 180(顺时针)] **Yaw**：三维旋转之左右旋转角[-90(左), 90(右)] | 分别小于20度                                                 |
| 人脸完整度 | **completeness**（0或1），0为人脸溢出图像边界， 1为人脸都在图像边界内 | 视业务逻辑判断                                               |
| 人脸大小   | 人脸部分的大小 建议长宽像素值范围：80*80~200*200             | 人脸部分不小于**100\*100**像素                               |


   如果不满足要求，需要告知用户，并重新拍照

### 5.1.4.3 人脸库的管理

* 把人脸照片保存并添加到人脸库中。

  ```python
  AipFace.addUser(image64, imageType, groupId, userId, options)
    image64: 经过base64编码和utf-8编码的照片
    imageType: "BASE64", 或者链接
    groupId: 照片在人脸库中的组id, 为字符串
    userId: 照片在人脸库中的用户id, 为字符串
    options: 可以提供其他选项.
  ```

  **人脸注册 请求参数详情**

| 参数名称         | 是否必选 | 类型   | 默认值 | 说明                                                         |
| ---------------- | -------- | ------ | ------ | ------------------------------------------------------------ |
| image            | 是       | string |        | 图片信息(**总数据大小应小于10M**)，图片上传方式根据image_type来判断 |
| image_type       | 是       | string |        | 图片类型 **BASE64**:图片的base64值，base64编码后的图片数据，需urlencode，编码后的图片大小不超过2M；**URL**:图片的 URL地址( 可能由于网络等原因导致下载图片时间过长)**；FACE_TOKEN**: 人脸图片的唯一标识，调用人脸检测接口时，会为每个人脸图片赋予一个唯一的FACE_TOKEN，同一张图片多次检测得到的FACE_TOKEN是同一个 |
| group_id         | 是       | string |        | 用户组id（由数字、字母、下划线组成），长度限制128B           |
| user_id          | 是       | string |        | 用户id（由数字、字母、下划线组成），长度限制128B             |
| user_info        | 否       | string |        | 用户资料，长度限制256B                                       |
| quality_control  | 否       | string | NONE   | 图片质量控制 **NONE**: 不进行控制 **LOW**:较低的质量要求 **NORMAL**: 一般的质量要求 **HIGH**: 较高的质量要求 **默认 NONE** |
| liveness_control | 否       | string | NONE   | 活体检测控制 **NONE**: 不进行控制 **LOW**:较低的活体要求(高通过率 低攻击拒绝率) **NORMAL**: 一般的活体要求(平衡的攻击拒绝率, 通过率) **HIGH**: 较高的活体要求(高攻击拒绝率 低通过率) **默认NONE** |

**人脸注册 返回数据参数详情**

| 字段       | 必选 | 类型   | 说明                                           |
| ---------- | ---- | ------ | ---------------------------------------------- |
| log_id     | 是   | uint64 | 请求标识码，随机数，唯一                       |
| face_token | 是   | string | 人脸图片的唯一标识                             |
| location   | 是   | array  | 人脸在图片中的位置                             |
| +left      | 是   | double | 人脸区域离左边界的距离                         |
| +top       | 是   | double | 人脸区域离上边界的距离                         |
| +width     | 是   | double | 人脸区域的宽度                                 |
| +height    | 是   | double | 人脸区域的高度                                 |
| +rotation  | 是   | int64  | 人脸框相对于竖直方向的顺时针旋转角，[-180,180] |

  **人脸注册 返回示例**

  ```
  {
    "face_token": "2fa64a88a9d5118916f9a303782a97d3",
    "location": {
        "left": 117,
        "top": 131,
        "width": 172,
        "height": 170,
        "rotation": 4
    }
  }
  ```

出错返回示例

```python
{'cached': 0,
 'error_code': 223120,
 'error_msg': 'liveness check fail',
 'log_id': 520199657965,
 'result': None,
 'timestamp': 1531398744}
```



### 5.1.4.4 签到验证

采集人脸数据，进行对比。同样需要调用人脸检测API, 判断是否符合要求，符合要求再调用搜索API。

* 人脸搜索
```python
client.search(image, imageType, groupIdList, options) 
```

**人脸搜索 请求参数详情**

| 参数名称         | 是否必选 | 类型   | 默认值 | 说明                                                         |
| ---------------- | -------- | ------ | ------ | ------------------------------------------------------------ |
| image            | 是       | string |        | 图片信息(**总数据大小应小于10M**)，图片上传方式根据image_type来判断 |
| image_type       | 是       | string |        | 图片类型 **BASE64**:图片的base64值，base64编码后的图片数据，需urlencode，编码后的图片大小不超过2M；**URL**:图片的 URL地址( 可能由于网络等原因导致下载图片时间过长)**；FACE_TOKEN**: 人脸图片的唯一标识，调用人脸检测接口时，会为每个人脸图片赋予一个唯一的FACE_TOKEN，同一张图片多次检测得到的FACE_TOKEN是同一个 |
| group_id_list    | 是       | string |        | 从指定的group中进行查找 用逗号分隔，**上限20个**             |
| quality_control  | 否       | string | NONE   | 图片质量控制 **NONE**: 不进行控制 **LOW**:较低的质量要求 **NORMAL**: 一般的质量要求 **HIGH**: 较高的质量要求 **默认 NONE** |
| liveness_control | 否       | string | NONE   | 活体检测控制 **NONE**: 不进行控制 **LOW**:较低的活体要求(高通过率 低攻击拒绝率) **NORMAL**: 一般的活体要求(平衡的攻击拒绝率, 通过率) **HIGH**: 较高的活体要求(高攻击拒绝率 低通过率) **默认NONE** |
| user_id          | 否       | string |        | 当需要对特定用户进行比对时，指定user_id进行比对。即人脸认证功能。 |
| max_user_num     | 否       | string |        | 查找后返回的用户数量。返回相似度最高的几个用户，默认为1，最多返回20个。 |

**人脸搜索 返回数据参数详情**

| 字段       | 必选 | 类型   | 说明                      |
| ---------- | ---- | ------ | ------------------------- |
| face_token | 是   | string | 人脸标志                  |
| user_list  | 是   | array  | 匹配的用户信息列表        |
| +group_id  | 是   | string | 用户所属的group_id        |
| +user_id   | 是   | string | 用户的user_id             |
| +user_info | 是   | string | 注册用户时携带的user_info |
| +score     | 是   | float  | 用户的匹配得分            |

**人脸搜索 返回示例**

```
{
  "face_token": "fid",
  "user_list": [
     {
        "group_id" : "test1",
        "user_id": "u333333",
        "user_info": "Test User",
        "score": 99.3
    }
  ]
}
```

## 5.1.5 百度人脸识别接口

案例实现BaiduFace类，包装了人脸库添加接口和人脸搜索接口。

```python
class BaiduFace(object):
    def __init__(self, app_id, app_key, secret_key):
        self.app_id = app_id
        self.app_key = app_key
        self.secret_key = secret_key
        self.token = None
        self.time_exp = None
        self.error = 0
        self.err_msg = ''

    def _get_token(self):
        self.error = 0
        self.err_msg = ''
        # 如果access_token 为 None 或者 token超时, 重新获取token
        if self.token == None or time.time() > self.time_exp:
            # client_id 为应用的API Key， client_secret 为应用的Secret Key
            token_url = 'https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&client_id=' \
                        + self.app_key + '&client_secret=' + self.secret_key

            # 构建http请求
            request = urllib.request.Request(token_url)
            request.add_header('Content-Type', 'application/json; charset=UTF-8')

            # 发送请求
            response = urllib.request.urlopen(request)

            # 读取返回信息
            content = response.read()

            # 解析返回结果
            content_decoded = json.loads(content.decode())

            # 判断返回结果
            if 'access_token' not in content_decoded:
                self.error = 1
                self.err_msg = content_decoded['error'] + ':' + content_decoded['error_description']
            else:
                self.token = content_decoded['access_token']

            self.time_exp = time.time() + content_decoded['expires_in'] // 2

        return self.error

    
    def add_user(self, img64, group_id, user_id, user_info=None):
        """
        添加人脸信息到人脸库
        :param img: 图片
        :param group_id:
        :param user_id:
        :param user_info:
        :return: 成功返回0, 否则返回 2
        """
        self.error = 0
        self.err_msg = ''

        if self._get_token() != 0:
            print(self.err_msg)
            return self.error

        # 准备调用参数
        params = {}
        params['image'] = img64
        params['image_type'] = 'BASE64'
        params['group_id'] = group_id
        params['user_id'] = user_id
        params['user_info'] = user_info
        params['quality_control'] = 'NORMAL'
        params['liveness_control'] = 'LOW'

        params = json.dumps(params).encode()

        # 服务URL 和 access token 参数
        api_url = 'https://aip.baidubce.com/rest/2.0/face/v3/faceset/user/add' + '?access_token=' + self.token

        # 构建http 请求
        request = urllib.request.Request(api_url, data=params)
        request.add_header('Content-Type', 'application/json; charset=UTF-8')

        # 发送请求
        response = urllib.request.urlopen(request)

        # 读取返回信息
        content = response.read()

        # 解析结果
        result = json.loads(content.decode())

        # pprint(result)

        if 'error_code' in result:
            self.error = result['error_code']
            self.err_msg = result['error_msg']

        return self.error

    def search_user(self, img64, group_id_list):
        """
        搜索图片库, 寻找匹配的照片
        :param img:
        :param group_id_list: 搜索的group 列表
        :return: 如果失败, 返回(error), 如果成功 返回 (0, group_id, user_id, user_info)
        """
        self.error = 0
        self.err_msg = ''

        if self._get_token() != 0:
            print(self.err_msg)
            return self.error

        # 准备调用参数
        params = {}
        params['image'] = img64
        params['image_type'] = 'BASE64'
        params['group_id_list'] = group_id_list
        params['quality_control'] = 'NORMAL'
        params['liveness_control'] = 'LOW'
        params['max_user_num'] = 1

        params = json.dumps(params).encode()

        # 服务URL 和 access token 参数
        api_url = 'https://aip.baidubce.com/rest/2.0/face/v3/search' + '?access_token=' + self.token

        # 构建http 请求
        request = urllib.request.Request(api_url, data=params)
        request.add_header('Content-Type', 'application/json; charset=UTF-8')

        # 发送请求
        response = urllib.request.urlopen(request)

        # 读取返回信息
        content = response.read()

        # 解析结果
        content_decoded = json.loads(content.decode())

        pprint(content_decoded)

        if content_decoded['error_code'] != 0:
            self.error = content_decoded['error_code']
            self.err_msg = content_decoded['error_msg']
            return {'error': self.error, "error_msg": self.err_msg}

        result = content_decoded['result']

        user = result['user_list'][0]
        user['error'] = self.error
        return user
```

## 5.1.6 main.py完整代码

```python
from flask import Flask, render_template, request, redirect, url_for, jsonify
from flask_migrate import Migrate, MigrateCommand
from flask_script import Manager
from flask_sqlalchemy import SQLAlchemy


from baidu_ai_face import bf

# 初始化flask应用
app = Flask(__name__)

# 设置应用参数: debug, session key, database uri
app.config['DEBUG'] = True
app.config['SECRET_KEY'] = "iECgbYWReMNxkRprrzMo5KAQYnb2UeZ3bwvReTSt+VSESW0OB8zbglT+6rEcDW9X"
app.config['SQLALCHEMY_DATABASE_URI'] = "mysql://root:123456@127.0.0.1:3306/school"
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

# 初始化数据库操作对象
db = SQLAlchemy(app)

class Student(db.Model):
    """
    定义数据库表格 结构类
    """
    __tablename__ = "students"
    # 标号
    id = db.Column(db.Integer, primary_key=True)
    # 学生姓名
    st_name = db.Column(db.String(128), nullable=False)
    # 学生班级
    st_class = db.Column(db.String(128), nullable=False)
    # 学生学号
    st_num = db.Column(db.String(128), unique=True, nullable=False)
    # 性别
    st_gender = db.Column(db.Enum("MAN","WOMAN"), default="MAN")

    def to_dict(self):
        return {
            "name": self.st_name,
            "class": self.st_class,
            "num": self.st_num,
            "gender": "男" if self.gender == "MAN" else "女"
        }

# 关联app 和数据库 对象
Migrate(app, db)

# 用 Manager 管理命令行参数
manager = Manager(app)

# 添加迁移命令
manager.add_command('db', MigrateCommand)

# 添加视图函数
@app.route('/')
def index():
    return render_template('index.html')


@app.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'GET':
        # 渲染注册模板
        return render_template('register.html')

    # POST 请求, 获取提交上来的参数
    st_name = request.form.get('stu_name')
    st_class = request.form.get('stu_class')
    st_num = request.form.get('stu_num')
    st_gender = request.form.get('gender')
    # print(st_name, st_class, st_num, st_gender)

    if all([st_name, st_class, st_num, st_gender]) == False:
        return render_template('register.html', msg='信息不全,请重新填写')

    # 初始化模板类,写入数据库
    student = Student()
    student.st_name = st_name
    student.st_class = st_class
    student.st_num = st_num
    student.st_gender = st_gender

    try:
        db.session.add(student)
        db.session.commit()
    except Exception as e:
        print('添加到数据库失败 {}'.format(e))
        return render_template('register.html', msg='信息不对, 请重新填写')

    # 获取图片内容
    img_data = request.form.get('img_data')

    # 上传百度, 用学生的学号作为唯一标识
    result = bf.add_user(img_data.split(',')[1], '1', st_num)

    if result != 0:
        # 需要把对应的信息从数据库中删除, 避免下次添加出错
        db.session.delete(student)

        return render_template('register.html', msg='图片不符合要求, 请重新拍照')

    # 成功添加后 重新定向到主页
    return redirect(url_for('index'))

@app.route('/clockin', methods=['GET', 'POST'])
def clockin():
    if request.method == 'GET':
        # 渲染打卡界面
        return render_template('clockin.html')

    # POST
    # 获取图片内容
    img_data = request.json.get('img_data')
    # print(img_data)
    result = bf.search_user(img_data.split(',')[1], '1')

    if result['error'] == 0:
        # 识别成功， 获取学号， 查询数据库获得更多学生信息
        student = Student.query.filter(Student.st_num == result['st_num']).first()
        if student:
            return jsonify(errno=0, errmsg='识别成功', dict=student.to_dict())
        else:
            return jsonify(errno=-1, errmsg='未能识别该学生')

    return jsonify(errno=result['error'], errmsg=result['error_msg'])

if __name__ == '__main__':
    manager.run()
```

